%% THIS NEEDS THE underscore PACKAGE: \usepackage[strings]{underscore}

\subsubsection{Class \texttt{rgams_SRS}}
\path{ruediPy/python/classes/rgams_SRS.py}\par
ruediPy class for SRS RGA-MS control.\par

\paragraph{Method \texttt{calibrate_all}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.calibrate_all()\newline
\newline
Calibrate the internal coefficients for compensation of baseline offset offset and peak positions. This will zero the baseline for all noise-floor (NF) and detector combinations. See also the "CA" command in the SRS RGA manual.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{calibrate_electrometer}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.calibrate_electrometer()\newline
\newline
Calibrate the electrometer I-V response curve (lookup table). See also the "CL" command in the SRS RGA manual.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{filament_off}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.filament_off()\newline
\newline
Turn off filament current.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{filament_on}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.filament_on()\newline
\newline
Turn on filament current at default current value.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{get_DI}}
\vspace{1ex}
\texttt{\newline
x = rgams_SRS.get_DI(x)\newline
\newline
Get current DI parameter value (peak-width tuning at low mz range)\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
x: DI value (bit units)\newline
\newline
NOTE:\newline
See also the SRS RGA manual, chapter 7, section "Peak Tuning Procedure"\newline
\newline
}

\paragraph{Method \texttt{get_DS}}
\vspace{1ex}
\texttt{\newline
x = rgams_SRS.get_DS(x)\newline
\newline
Get current DS parameter value (peak-width tuning at high mz range)\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
x: DS value (bit/amu units)\newline
\newline
NOTE:\newline
See also the SRS RGA manual, chapter 7, section "Peak Tuning Procedure"\newline
\newline
}

\paragraph{Method \texttt{get_RI}}
\vspace{1ex}
\texttt{\newline
x = rgams_SRS.get_RI(x)\newline
\newline
Get current RI parameter value (peak-position tuning at low mz range / RF voltage output at 0 amu, in mV).\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
x: RI voltage (in mV)\newline
\newline
NOTE:\newline
See also the SRS RGA manual, chapter 7, section "Peak Tuning Procedure"\newline
\newline
}

\paragraph{Method \texttt{get_RS}}
\vspace{1ex}
\texttt{\newline
x = rgams_SRS.get_RS(x)\newline
\newline
Get current RS parameter value (peak-position tuning at high mz range  / RF voltage output at 128 amu, in mV)\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
x: RS voltage (in mV)\newline
\newline
NOTE:\newline
See also the SRS RGA manual, chapter 7, section "Peak Tuning Procedure"\newline
\newline
}

\paragraph{Method \texttt{get_default_RI}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.get_default_RI()\newline
\newline
Return default RI value.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
val: default RI value\newline
\newline
}

\paragraph{Method \texttt{get_default_RS}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.get_default_RS()\newline
\newline
Return default RS value.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
val: default RS value\newline
\newline
}

\paragraph{Method \texttt{get_detector}}
\vspace{1ex}
\texttt{\newline
det = rgams_SRS.get_detector()\newline
\newline
Return current detector (Faraday or electron multiplier)\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
det: detecor (string):\newline
det='F' for Faraday\newline
det='M' for electron Multiplier\newline
\newline
}

\paragraph{Method \texttt{get_electron_emission}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.get_electron_emission()\newline
\newline
Return electron emission current (in mA)\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
val: electron emission current in mA (float)\newline
\newline
}

\paragraph{Method \texttt{get_electron_energy}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.get_electron_energy()\newline
\newline
Return electron energy of the ionizer (in eV).\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
val: electron energy in eV\newline
\newline
}

\paragraph{Method \texttt{get_multiplier_default_hv}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.get_multiplier_default_hv()\newline
\newline
Return default value to be used for electron multiplier (CEM) high voltage (bias voltage).\newline
NOTE: the value returned is NOT the value stored in the memory of the RGA head. This function is just a wrapper that returns the default high voltage value set in the RGA object (e.g., during initialisation of the object).\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
val: voltage\newline
\newline
}

\paragraph{Method \texttt{get_multiplier_hv}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.get_multiplier_hv()\newline
\newline
Return electron multiplier (CEM) high voltage (bias voltage).\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
val: voltage\newline
\newline
}

\paragraph{Method \texttt{get_noise_floor}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.get_noise_floor()\newline
\newline
Get noise floor (NF) parameter for RGA measurements (noise floor controls gate time, i.e., noise vs. measurement speed).\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
val: NF noise floor parameter value, 0...7 (integer)\newline
\newline
}

\paragraph{Method \texttt{has_multiplier}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.has_multiplier()\newline
\newline
Check if MS has electron multiplier installed.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
val: result flag, val = 0 --> MS has no multiplier, val <> 0: MS has multiplier\newline
\newline
}

\paragraph{Method \texttt{ionizer_degas}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.ionizer_degas(duration)\newline
\newline
Run the ionizer degas procedure (see SRS RGA manual). Only run this with sufficiently good vacuum!\newline
\newline
INPUT:\newline
duration: degas time in minutes (0...20 / integer)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{label}}
\vspace{1ex}
\texttt{\newline
l = rgams_SRS.label()\newline
\newline
Return label / name of the RGAMS object.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
l: label / name (string)\newline
\newline
}

\paragraph{Method \texttt{mz_max}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.mz_max()\newline
\newline
Determine highest mz value supported by the MS.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
val: max. supported mz value (int)\newline
\newline
}

\paragraph{Method \texttt{param_IO}}
\vspace{1ex}
\texttt{\newline
ans = rgams_SRS.param_IO(cmd,ansreq)\newline
\newline
Set / read parameter value of the SRS RGA.\newline
\newline
INPUT:\newline
cmd: command string that is sent to RGA (see RGA manual for commands and syntax)\newline
ansreq: flag indicating if answer from RGA is expected:\newline
ansreq = 1: answer expected, check for answer\newline
ansreq = 0: no answer expected, don't check for answer\newline
timeout (optional): max. wait time for answer from RGA (seconds), default: timeout = 10 seconds\newline
\newline
OUTPUT:\newline
ans: answer / result returned from RGA\newline
\newline
}

\paragraph{Method \texttt{peak}}
\vspace{1ex}
\texttt{\newline
val,unit = rgams_SRS.peak(mz,gate,f,add_to_peakbuffer=True)\newline
\newline
Read out detector signal at single mass (m/z value).\newline
\newline
INPUT:\newline
mz: m/z value (integer)\newline
gate: gate time (seconds) NOTE: gate time can be longer than the max. gate time supported by the hardware (2.4 seconds). If so, the multiple peak readings will be averaged to achieve the requested gate time.\newline
f: file object for writing data (see datafile.py). If f = 'nofile', data is not written to any data file.\newline
add_to_peakbuffer (optional): flag to choose if peak value is added to peakbuffer (default: add_to_peakbuffer=True)\newline
\newline
OUTPUT:\newline
val: signal intensity (float)\newline
unit: unit (string)\newline
\newline
NOTE FROM THE SRS RGA MANUAL:\newline
Single mass measurements are commonly performed in sets\newline
where several different masses are monitored sequencially\newline
and in a merry-go-round fashion.\newline
For best accuracy of results, it is best to perform the consecutive\newline
mass measurements in a set with the same type of detector\newline
and at the same noise floor (NF) setting.\newline
Fixed detector settings eliminate settling time problems\newline
in the electrometer and in the CDEM's HV power supply.\newline
\newline
}

\paragraph{Method \texttt{peak_zero_loop}}
\vspace{1ex}
\texttt{\newline
peak_zero_loop (mz,detector,gate,ND,NC,datafile,clear_peakbuf_cond=True,clear_peakbuf_main=True,plot_cond=False)\newline
\newline
Cycle PEAKS and ZERO readings given mz values.\newline
\newline
INPUT:\newline
mz: list of tuples with peak m/z value (for PEAK) and delta-mz (for ZERO). If delta-mz == 0, no ZERO value is read.\newline
detector: detector string ('F' or 'M')\newline
gate: integration time\newline
ND: number of data cycles recorded to the current data file\newline
NC: number of cycles used for conditioning of the detector and electronics before recording the data (not written to datafile)\newline
datafile: file object for writing data (see datafile.py). If f = 'nofile', data is not written to any data file.\newline
clear_peakbuf_cond: flag to set clearing of peakbuffer before conditioning cycles on/off (optional, default=True)\newline
clear_peakbuf_main: flag to set clearing of peakbuffer before main cycles on/off (optional, default=True)\newline
plot_cond: flag to set plotting of readings used for detector conditioning (inclusion of values in peakbuffer)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{peakbuffer_add}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.peakbuffer_add(t,mz,intens,unit)\newline
\newline
Add data to PEAKS data buffer\newline
\newline
INPUT:\newline
t: epoch time\newline
mz: mz values\newline
intens: intensity value\newline
det: detector (char/string)\newline
unit: unit of intensity value (char/string)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{peakbuffer_clear}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.peakbuffer_clear()\newline
\newline
Clear data in PEAKS data buffer\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{peakbuffer_set_length}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.peakbuffer_set_length(N)\newline
\newline
Set max. length of peakbuffer\newline
\newline
INPUT:\newline
N: number of PEAK values\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{plot_peakbuffer}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.plot_peakbuffer()\newline
\newline
Plot trend (or update plot) of values in PEAKs data buffer (e.g. after adding data)\newline
NOTE: plotting may be slow, and it may therefore be a good idea to keep the update interval low to avoid affecting the duty cycle.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{plot_scan}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.plot_scan(mz,intens,unit,cumsum_mz=[],cumsum_val=[])\newline
\newline
Plot scan data\newline
\newline
INPUT:\newline
mz: mz values (x-axis)\newline
intens: intensity values (y-axis)\newline
unit: intensity unit (string)\newline
cumsum_mz,cumsum_val (optional): cumulative sum of peak data (mz and sum values), as used for peak centering\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{print_status}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.print_status()\newline
\newline
Print status of the RGA head.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{scan}}
\vspace{1ex}
\texttt{\newline
M,Y,unit = rgams_SRS.scan(low,high,step,gate,f)\newline
\newline
Analog scan\newline
\newline
INPUT:\newline
low: low m/z value (integer or decimal)\newline
high: high m/z value (integer or decimal)\newline
step: scan resolution (number of mass increment steps per amu)\newline
step = integer number (10...25) --> use given number (high number equals small mass increments between steps)\newline
step = '*' use default value (step = 10)\newline
gate: gate time (seconds)\newline
f: file object or 'nofile':\newline
if f is a DATAFILE object, the scan data is written to the current data file\newline
if f = 'nofile' (string), the scan data is not written to a datafile\newline
\newline
OUTPUT:\newline
M: mass values (mz, in amu)\newline
Y: signal intensity values (float)\newline
unit: unit of Y (string)\newline
\newline
}

\paragraph{Method \texttt{set_DI}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.set_DI(x)\newline
\newline
Set DI parameter value (Peak width parameter at m/z = 0)\newline
\newline
INPUT:\newline
x: parameter value (bit units)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
NOTE:\newline
See also the SRS RGA manual, chapter 7, section "Peak Tuning Procedure"\newline
\newline
}

\paragraph{Method \texttt{set_DS}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.set_DS(x)\newline
\newline
Set DS parameter value (Peak width parameter for m/z > 0)\newline
\newline
INPUT:\newline
x: parameter value (bit/amu units)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
NOTE:\newline
See also the SRS RGA manual, chapter 7, section "Peak Tuning Procedure"\newline
\newline
}

\paragraph{Method \texttt{set_RI}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.set_RI(x)\newline
\newline
Set RI parameter value (peak-position tuning at low mz range / RF voltage output at 0 amu, in mV)\newline
\newline
INPUT:\newline
x: RI voltage (mV)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
NOTE:\newline
See also the SRS RGA manual, chapter 7, section "Peak Tuning Procedure"\newline
\newline
}

\paragraph{Method \texttt{set_RS}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.set_RS(x)\newline
\newline
Set RS parameter value (peak-position tuning at high mz range  / RF voltage output at 128 amu, in mV)\newline
\newline
INPUT:\newline
x: RS voltage (mV)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
NOTE:\newline
See also the SRS RGA manual, chapter 7, section "Peak Tuning Procedure"\newline
\newline
}

\paragraph{Method \texttt{set_detector}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.set_detector(det)\newline
\newline
Set current detetector used by the MS (direct the ion beam to the Faraday or electron multiplier detector).\newline
NOTE: To activate the electron multiplier (CEM), the default high voltage (bias voltage) as returned by self.get_multi_default_hv() is used (this is NOT necessarily the same as the default value stored in the RGA head).\newline
\newline
INPUT:\newline
det: detecor (string):\newline
det='F' for Faraday\newline
det='M' for electron multiplier\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{set_electron_emission}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.set_electron_emission(val)\newline
\newline
Set electron emission current.\newline
\newline
INPUT:\newline
val: electron emission current in mA (0 ... 3.5 mA)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{set_electron_energy}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.set_electron_energy(val)\newline
\newline
Set electron energy of the ionizer.\newline
\newline
INPUT:\newline
val: electron energy in eV\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{set_gate_time}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.set_gate_time()\newline
\newline
Set noise floor (NF) parameter for RGA measurements according to desired gate time (by choosing the best-match NF value).\newline
\newline
INPUT:\newline
gate: gate time in (fractional) seconds\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
NOTE (1):\newline
FROM THE SRS RGA MANUAL:\newline
Single mass measurements are commonly performed in sets\newline
where several different masses are monitored sequencially\newline
and in a merry-go-round fashion.\newline
For best accuracy of results, it is best to perform the consecutive\newline
mass measurements in a set with the same type of detector\newline
and at the same noise floor (NF) setting.\newline
Fixed detector settings eliminate settling time problems\newline
in the electrometer and in the CDEM HV power supply.\newline
\newline
NOTE (2):\newline
Experiment gave the following gate times vs NF parameter values:\newline
\newline
NF	gate (seconds)\newline
0	2.4	  \newline
1	1.21	  \newline
2	0.48	  \newline
3	0.25	  \newline
4	0.163 \newline
5	0.060 \newline
6	0.043 \newline
7	0.025 \newline
\newline
}

\paragraph{Method \texttt{set_multiplier_hv}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.set_multiplier_hv(val)\newline
\newline
Set electron multiplier (CEM) high voltage (bias voltage).\newline
\newline
INPUT:\newline
val: voltage\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{set_noise_floor}}
\vspace{1ex}
\texttt{\newline
val = rgams_SRS.set_noise_floor()\newline
\newline
Set noise floor (NF) parameter for RGA measurements (noise floor controls gate time, i.e., noise vs. measurement speed).\newline
\newline
INPUT:\newline
NF: noise floor parameter value, 0...7 (integer)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{set_peakbuffer_plot_max_y}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.set_peakbuffer_plot_max_y(val)\newline
\newline
Set upper limit of y range in peakbuffer plot.\newline
\newline
INPUT:\newline
val: upper limit of y-axis range\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{set_peakbuffer_plot_min_y}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.set_peakbuffer_plot_min_y(val)\newline
\newline
Set lower limit of y range in peakbuffer plot.\newline
\newline
INPUT:\newline
val: lower limit of y-axis range\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{tune_peak_position}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.tune_peak_position(mz,gate,det,max_iter=10,max_delta_mz=0.05,use_defaults=False,resolution=25)\newline
\newline
Automatically adjust peak positions in mass spectrum to make sure peaks show up at the correct mz values. This is done by scanning peaks at different mz values, and determining their offset in the mz spectrum. The mass spectromter parameters are then adjusted to minimize the mz offsets (parameters RI and RF, which define the peak positions at mz=0 and mz=128). The procedure start with the currently set RI and RS values (if use_defaults = False) or the default values (if they are set and use_defaults = True). This needs at least two distinct peak mz values, one at a low and one at a high mz value. The procedure is repeated until either the peak position offsets at mz=0 and mz=128 are less than max_delta_mz or the number of iterations has reached max_iter.\newline
\newline
INPUT:\newline
peaks: list of (mz,width,gate,detector) tuples, where peaks should be scanned and tuned\newline
mz = mz value of peak (center of the scan)\newline
width = width of the peak (relative to center mz value)\newline
gate: gate time to be used for the scan\newline
detector: detector to be used for the scan ('F' or 'M')\newline
max_iter (optional): max. number of repetitions of the tune procedure\newline
maxdelta_mz (optional): tolerance of mz offset at mz=0 and mz=128. If the absolute offsets at mz=0 and mz=128 after tuning are less than maxdelta_z after tuning, the tuning procedure is stopped.\newline
use_defaults: flag to set if default RI and RS values are used to start the tuning procedure. Default value: use_defaults = False\newline
resolution: m/z resolution used for the scans (10...25 points per amu). Default = 25 points per amu.\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
EXAMPLE:\newline
>>> MS = rgams_SRS ( serialport = '/dev/serial/by-id/usb-WuT_USB_Cable_2_WT2016234-if00-port0' , label = 'MS_MINIRUEDI_TEST', max_buffer_points = 1000 )\newline
>>> MS.filament_on()\newline
>>> MS.tune_peak_position([14,18,28,32,40,44,84],[0.2,0.2,0.025,0.1,0.4,0.1,2.4],['F','F','F','F','F','M','M'],10)\newline
\newline
NOTE:\newline
See also the SRS RGA manual, chapter 7, section "Peak Tuning Procedure"\newline
\newline
}

\paragraph{Method \texttt{warning}}
\vspace{1ex}
\texttt{\newline
rgams_SRS.warning(msg)\newline
\newline
Issue warning about issues related to operation of MS.\newline
\newline
INPUT:\newline
msg: warning message (string)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{zero}}
\vspace{1ex}
\texttt{\newline
val,unit = rgams_SRS.zero(mz,mz_offset,gate,f)\newline
\newline
Read out detector signal at single mass with relative offset to given m/z value (this is useful to determine the baseline near a peak at a given m/z value), see rgams_SRS.peak())\newline
The detector signal is read at mz+mz_offset\newline
\newline
INPUT:\newline
mz: m/z value (integer)\newline
mz_offset: offset relative m/z value (integer).\newline
gate: gate time (seconds) NOTE: gate time can be longer than the max. gate time supported by the hardware (2.4 seconds). If so, the multiple zero readings will be averaged to achieve the requested gate time.\newline
f: file object for writing data (see datafile.py). If f = 'nofile', data is not written to any data file.\newline
\newline
OUTPUT:\newline
val: signal intensity (float)\newline
unit: unit (string)\newline
\newline
NOTE FROM THE SRS RGA MANUAL:\newline
Single mass measurements are commonly performed in sets\newline
where several different masses are monitored sequencially\newline
and in a merry-go-round fashion.\newline
For best accuracy of results, it is best to perform the consecutive\newline
mass measurements in a set with the same type of detector\newline
and at the same noise floor (NF) setting.\newline
Fixed detector settings eliminate settling time problems\newline
in the electrometer and in the CDEM's HV power supply.\newline
\newline
}

\subsubsection{Class \texttt{selectorvalve_VICI}}
\path{ruediPy/python/classes/selectorvalve_VICI.py}\par
ruediPy class for VICI valve control. This assumes the serial protocol used with VICI's older "microlectric" actuators. For use with the newer "universal" actuators, they must be set to "legacy mode" using the "LG1" command (see page 8 of VICI document "Universal Electric Actuator Instruction Manual"). The self.set_legacy command may be useful for this.\par

\paragraph{Method \texttt{getpos}}
\vspace{1ex}
\texttt{\newline
pos = selectorvalve_VICI.getpos()\newline
\newline
Get valve position\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
pos: valve postion (integer)\newline
\newline
}

\paragraph{Method \texttt{label}}
\vspace{1ex}
\texttt{\newline
label = selectorvalve_VICI.label()\newline
\newline
Return label / name of the SELECTORVALVE object\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
label: label / name (string)\newline
\newline
}

\paragraph{Method \texttt{set_legacy}}
\vspace{1ex}
\texttt{\newline
selectorvalve_VICI.set_legacy()\newline
\newline
Set communication protocol to LEGACY mode (useful to make the newer valve controlers compatible with the LEGACY protocol).\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{setpos}}
\vspace{1ex}
\texttt{\newline
selectorvalve_VICI.setpos(val,f)\newline
\newline
Set valve position\newline
\newline
INPUT:\newline
val: new valve position (integer)\newline
f: datafile object for writing data (see datafile.py). If f = 'nofile', data is not written to any data file.\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{warning}}
\vspace{1ex}
No method description available.\par

\subsubsection{Class \texttt{pressuresensor_WIKA}}
\path{ruediPy/python/classes/pressuresensor_WIKA.py}\par
ruediPy class for WIKA pressure sensor control.\par

\paragraph{Method \texttt{label}}
\vspace{1ex}
\texttt{\newline
label = pressuresensor_WIKA.label()\newline
\newline
Return label / name of the PRESSURESENSOR object\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
label: label / name (string)\newline
\newline
}

\paragraph{Method \texttt{plot_pressbuffer}}
\vspace{1ex}
\texttt{\newline
pressuresensor_WIKA.plot_pressbuffer()\newline
\newline
Plot trend (or update plot) of values in pressure data buffer (e.g. after adding data)\newline
NOTE: plotting may be slow, and it may therefore be a good idea to keep the update interval low to avoid affecting the duty cycle.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{pressbuffer_add}}
\vspace{1ex}
\texttt{\newline
pressuresensor_WIKA.pressbuffer_add(t,p,unit)\newline
\newline
Add data to pressure data buffer\newline
\newline
INPUT:\newline
t: epoch time\newline
p: pressure value\newline
unit: unit of pressure value (char/string)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{pressbuffer_clear}}
\vspace{1ex}
\texttt{\newline
pressuresensor_WIKA.pressbuffer_clear()\newline
\newline
Clear the buffer of pressure readings\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{pressure}}
\vspace{1ex}
\texttt{\newline
press,unit = pressuresensor_WIKA.pressure(f,add_to_pressbuffer=True)\newline
\newline
Read out current pressure value.\newline
\newline
INPUT:\newline
f: file object for writing data (see datafile.py). If f = 'nofile', data is not written to any data file.\newline
add_to_pressbuffer (optional): flag to indicate if data get appended to pressure buffer (default=True)\newline
\newline
OUTPUT:\newline
press: pressure value in hPa (float)\newline
unit: unit of pressure value (string)\newline
\newline
}

\paragraph{Method \texttt{serial_checksum}}
\vspace{1ex}
\texttt{\newline
cs = pressuresensor_WIKA.serial_checksum( cmd )\newline
\newline
Return checksum used for serial port communication with WIKA pressure sensor.\newline
\newline
INPUT:\newline
cmd: serial-port command string without checksum\newline
\newline
OUTPUT:\newline
cs: checksum byte\newline
\newline
}

\paragraph{Method \texttt{warning}}
\vspace{1ex}
\texttt{\newline
pressuresensor_WIKA.warning(msg)\newline
\newline
Issue warning about issues related to operation of pressure sensor.\newline
\newline
INPUT:\newline
msg: warning message (string)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\subsubsection{Class \texttt{pressuresensor_OMEGA}}
\path{ruediPy/python/classes/pressuresensor_OMEGA.py}\par
ruediPy class for OMEGA pressure sensor control.\par

\paragraph{Method \texttt{label}}
\vspace{1ex}
\texttt{\newline
label = pressuresensor_OMEGA.label()\newline
\newline
Return label / name of the PRESSURESENSOR object\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
label: label / name (string)\newline
\newline
}

\paragraph{Method \texttt{plot_pressbuffer}}
\vspace{1ex}
\texttt{\newline
pressuresensor_OMEGA.plot_pressbuffer()\newline
\newline
Plot trend (or update plot) of values in pressure data buffer (e.g. after adding data)\newline
NOTE: plotting may be slow, and it may therefore be a good idea to keep the update interval low to avoid affecting the duty cycle.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{pressbuffer_add}}
\vspace{1ex}
\texttt{\newline
pressuresensor_OMEGA.pressbuffer_add(t,p,unit)\newline
\newline
Add data to pressure data buffer\newline
\newline
INPUT:\newline
t: epoch time\newline
p: pressure value\newline
unit: unit of pressure value (char/string)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{pressbuffer_clear}}
\vspace{1ex}
\texttt{\newline
pressuresensor_OMEGA.pressbuffer_clear()\newline
\newline
Clear the buffer of pressure readings\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{pressure}}
\vspace{1ex}
\texttt{\newline
press,unit = pressuresensor_OMEGA.pressure(f,add_to_pressbuffer=True)\newline
\newline
Read out current pressure value.\newline
\newline
INPUT:\newline
f: file object for writing data (see datafile.py). If f = 'nofile', data is not written to any data file.\newline
add_to_pressbuffer (optional): flag to indicate if data get appended to pressure buffer (default=True)\newline
\newline
OUTPUT:\newline
press: pressure value in hPa (float)\newline
unit: unit of pressure value (string)\newline
\newline
}

\paragraph{Method \texttt{warning}}
\vspace{1ex}
\texttt{\newline
pressuresensor_OMEGA.warning(msg)\newline
\newline
Issue warning about issues related to operation of pressure sensor.\newline
\newline
INPUT:\newline
msg: warning message (string)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\subsubsection{Class \texttt{temperaturesensor_MAXIM}}
\path{ruediPy/python/classes/temperaturesensor_MAXIM.py}\par
ruediPy class for MAXIM DS1820 type temperature sensors (wrapper class for pydigitemp package).\par

\paragraph{Method \texttt{label}}
\vspace{1ex}
\texttt{\newline
label = temperaturesensor_MAXIM.label()\newline
\newline
Return label / name of the TEMPERATURESENSOR object\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
label: label / name (string)\newline
\newline
}

\paragraph{Method \texttt{plot_tempbuffer}}
\vspace{1ex}
\texttt{\newline
temperaturesensor_MAXIM.plot_tempbuffer()\newline
\newline
Plot trend (or update plot) of values in temperature data buffer (e.g. after adding data)\newline
NOTE: plotting may be slow, and it may therefore be a good idea to keep the update interval low to avoid affecting the duty cycle.\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{tempbuffer_add}}
\vspace{1ex}
\texttt{\newline
temperaturesensor_MAXIM.tempbuffer_add(t,T,unit)\newline
\newline
Add data to temperature data buffer\newline
\newline
INPUT:\newline
t: epoch time\newline
T: temperature value\newline
unit: unit of pressure value (char/string)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{tempbuffer_clear}}
\vspace{1ex}
\texttt{\newline
temperaturesensor_MAXIM.pressbuffer_clear()\newline
\newline
Clear the buffer of temperature readings\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{temperature}}
\vspace{1ex}
\texttt{\newline
temp,unit = temperaturesensor_MAXIM.temperature(f)\newline
\newline
Read out current temperaure value.\newline
\newline
INPUT:\newline
f: file object for writing data (see datafile.py). If f = 'nofile', data is not written to any data file.\newline
add_to_tempbuffer (optional): flag to indicate if data get appended to temperature buffer (default=True)\newline
\newline
OUTPUT:\newline
temp: temperature value (float)\newline
unit: unit of temperature value (string)\newline
\newline
}

\paragraph{Method \texttt{warning}}
\vspace{1ex}
\texttt{\newline
temperaturesensor_MAXIM.warning(msg)\newline
\newline
Issue warning about issues related to operation of pressure sensor.\newline
\newline
INPUT:\newline
msg: warning message (string)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\subsubsection{Class \texttt{datafile}}
\path{ruediPy/python/classes/datafile.py}\par
ruediPy class for handling of data files.\par

\paragraph{Method \texttt{basepath}}
\vspace{1ex}
\texttt{\newline
pat = datafile.basepath()\newline
\newline
Return the base path where datafiles are stored\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
pat: datafile base path (string)\newline
\newline
}

\paragraph{Method \texttt{close}}
\vspace{1ex}
\texttt{\newline
datafile.close()\newline
\newline
Close the currently open data file (if any)\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{fid}}
\vspace{1ex}
\texttt{\newline
f = datafile.fid()\newline
\newline
Return the file ID / object of the current file\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
f: datafile object\newline
\newline
}

\paragraph{Method \texttt{label}}
\vspace{1ex}
\texttt{\newline
lab = datafile.label()\newline
\newline
Return label / name of the DATAFILE object\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
lab: label / name (string)\newline
\newline
}

\paragraph{Method \texttt{name}}
\vspace{1ex}
\texttt{\newline
n = datafile.name()\newline
\newline
Return the name the current file (or empty string if not datafile has been created)\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
n: ile name (string)\newline
\newline
}

\paragraph{Method \texttt{next}}
\vspace{1ex}
\texttt{\newline
datafile.next( typ='MISC' , samplename='' , standardconc=[] )\newline
\newline
Close then current data file (if it's still open) and start a new file.\newline
\newline
INPUT:\newline
typ (optional): analysis type (string, default: typ = 'MISC'). The analysis type is written to the data file, and is appended to the file name. typ can be one of the following analysis types:\newline
typ = 'SAMPLE' (for sample analyses)\newline
typ = 'STANDARD' (for standard / calibration analyses)\newline
typ = 'BLANK' (for blank analyses)\newline
typ = 'MISC' (for miscellaneous analysis types, useful for testing, maintenance, or similar purposes)\newline
samplename (optional, only used if typ='SAMPLE'): description, name, or ID of sample (string)\newline
standardconc (optional, only used if typ='STANDARD'): standard gas information, list of 3-tuples, one tuple for each mz-value). Each tuple has the following 3 fields:\newline
field-1: name of species (string)\newline
field-2: volumetric species concentration in standard gas\newline
field-3: mz value used for analysis of this species\newline
\newline
example for N2 and Ar-40 in air, analyzed on mz=28 and mz=40: standardconc = [ ('N2',0.781,28) , ('Ar-40',0.9303,40) ]\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{warning}}
\vspace{1ex}
\texttt{\newline
datafile.warning(msg)\newline
\newline
Warn about issues related to DATAFILE object\newline
\newline
INPUT:\newline
msg: warning message (string)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{write_comment}}
\vspace{1ex}
\texttt{\newline
datafile.write_comment(caller,cmt)\newline
\newline
Write COMMENT line to the data file.\newline
\newline
INPUT:\newline
caller: label / name of the calling object (string)\newline
cmt: comment string\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{write_peak}}
\vspace{1ex}
\texttt{\newline
datafile.write_peak(caller,mz,intensity,unit,det,gate,timestmp)\newline
\newline
Write PEAK data line to the data file.\newline
\newline
INPUT:\newline
caller: type of calling object, i.e. the "data origin" (string)\newline
label: name/label of the calling object (string)\newline
mz: mz value (integer)\newline
intensity: peak intensity value (float)\newline
unit: unit of peak intensity value (string)\newline
det: detector (string), e.g., det='F' for Faraday or det='M' for multiplier\newline
gate: gate time (float)\newline
timestmp: timestamp of the peak measurement (see misc.now_UNIX)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{write_pressure}}
\vspace{1ex}
\texttt{\newline
datafile.write_pressure(caller,label,value,unit,timestmp)\newline
\newline
Write PRESSURE data line to the data file.\newline
\newline
INPUT:\newline
caller: type of calling object, i.e. the "data origin" (string)\newline
label: name/label of the calling object (string)\newline
value: pressure value (float)\newline
unit: unit of peak intensity value (string)\newline
timestmp: timestamp of the pressure measurement (see misc.now_UNIX)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{write_sample_desc}}
\vspace{1ex}
\texttt{\newline
datafile.write_sample_desc(self,desc)\newline
\newline
Write line with sample description (e.g., name or ID of sample)\newline
\newline
INPUT:\newline
desc: sample description, name, or ID (string)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{write_scan}}
\vspace{1ex}
\texttt{\newline
datafile.write_scan(caller,mz,intensity,unit,det,gate,timestmp)\newline
\newline
Write PEAK data line to the data file.\newline
\newline
INPUT:\newline
caller: type of calling object, i.e. the "data origin" (string)\newline
label: name/label of the calling object (string)\newline
mz: mz values (floats)\newline
intensity: intensity values (floats)\newline
unit: unit of intensity values (string)\newline
det: detector (string), e.g., det='F' for Faraday or det='M' for multiplier\newline
gate: gate time (float)\newline
timestmp: timestamp of the peak measurement (see misc.now_UNIX)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{write_standard_conc}}
\vspace{1ex}
\texttt{\newline
datafile.write_standard_conc(species,conc,mz)\newline
\newline
Write line with standard/calibration gas information to data file: name, concentration/mixing ratio, and mz value of gas species.\newline
\newline
INPUT:\newline
caller: type of calling object, i.e. the "data origin" (string)\newline
species: name of gas species (string)\newline
conc: volumetric concentration / mixing ratio (float)\newline
mz: mz value (integer)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{write_temperature}}
\vspace{1ex}
\texttt{\newline
datafile.write_temperature(caller,label,value,unit,timestmp)\newline
\newline
Write TEMPERATURE data line to the data file.\newline
\newline
INPUT:\newline
caller: type of calling object, i.e. the "data origin" (string)\newline
label: name/label of the calling object (string)\newline
value: temperature value (float)\newline
unit: unit of peak intensity value (string)\newline
timestmp: timestamp of the temperature measurement (see misc.now_UNIX)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{write_valve_pos}}
\vspace{1ex}
\texttt{\newline
datafile.write_valve_pos(caller,position,timestmp)\newline
\newline
Write multi-port valve position data line to the data file.\newline
\newline
INPUT:\newline
caller: type of calling object, i.e. the "data origin" (string)\newline
label: name/label of the calling object (string)\newline
position: valve position (integer)\newline
timestmp: timestamp of the peak measurement (see misc.now_UNIX)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{write_zero}}
\vspace{1ex}
\texttt{\newline
datafile.write_zero(caller,mz,mz_offset,intensity,unit,det,gate,timestmp)\newline
\newline
Write ZERO data line to the data file.\newline
\newline
INPUT:\newline
caller: type of calling object, i.e. the "data origin" (string)\newline
label: name/label of the calling object (string)\newline
mz: mz value (integer)\newline
mz_offset: mz offset value (integer, positive offset corresponds to higher mz value)\newline
intensity: zero intensity value (float)\newline
unit: unit of peak intensity value (string)\newline
det: detector (string), e.g., det='F' for Faraday or det='M' for multiplier\newline
gate: gate time (float)\newline
timestmp: timestamp of the peak measurement (see misc.now_UNIX)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{writeln}}
\vspace{1ex}
\texttt{\newline
datafile.writeln(caller,identifier,data,timestmp)\newline
\newline
Write a text line to the data file (format: TIMESTAMP CALLER[LABEL] IDENTIFIER: DATA). CALLER, LABEL, and IDENTIFIER should not contain spaces or similar white space (will be removed before writing to file). If LABEL == '' or LABEL == CALLER, the [LABEL] part is omitted.\newline
\newline
INPUT:\newline
caller: type of calling object, i.e. the "data origin" (string)\newline
label: name/label of the calling object (string)\newline
identifier: data type identifier (string)\newline
data: data / info string\newline
timestmp: timestamp of the data in unix time (see misc.now_UNIX)\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\subsubsection{Class \texttt{misc}}
\path{ruediPy/python/classes/misc.py}\par
ruediPy class with helper functions.\par

\paragraph{Method \texttt{ask_for_value}}
\vspace{1ex}
\texttt{\newline
x = misc.ask_for_value(msg='Enter value = ')\newline
\newline
Print a message asking the user to enter something, wait until the user presses the ENTER key, and return the value.\newline
\newline
INPUT:\newline
msg (optional): message\newline
\newline
OUTPUT:\newline
x: user value (string)\newline
\newline
}

\paragraph{Method \texttt{now_UNIX}}
\vspace{1ex}
\texttt{\newline
dt = misc.now_UNIX()\newline
\newline
Return date/time as UNIX time / epoch (seconds after Jan 01 1970 UTC)\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
dt: date-time (UNIX / epoch time)\newline
\newline
}

\paragraph{Method \texttt{now_string}}
\vspace{1ex}
\texttt{\newline
dt = misc.now_string()\newline
\newline
Return string with current date and time\newline
\newline
INPUT:\newline
(none)\newline
\newline
OUTPUT:\newline
dt: date-time (string) in YYYY-MM-DD hh:mm:ss format\newline
\newline
}

\paragraph{Method \texttt{sleep}}
\vspace{1ex}
\texttt{\newline
misc.sleep( wait , msg='' )\newline
\newline
Wait for a specified time and print a countdown message. The user can skip the countdown by pressing CTRL-C.\newline
\newline
INPUT:\newline
wait: waiting time (seconds)\newline
msg (optional): message\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{user_menu}}
\vspace{1ex}
\texttt{\newline
x = misc.user_menu(menu,title='Choose an option')\newline
\newline
Show a "menu" for selection of different user options, return user choice based on key pressed by user.\newline
\newline
INPUT:\newline
menu: menu entries (tuple of strings)\newline
title (optional): title of the menu (default='Choose an option')\newline
\newline
OUTPUT:\newline
x: number of menu choice\newline
\newline
EXAMPLE:\newline
k = misc.user_menu( title='Choose dinner' , menu=('Chicken','Burger','Veggies') )\newline
\newline
}

\paragraph{Method \texttt{wait_for_enter}}
\vspace{1ex}
\texttt{\newline
misc.wait_for_enter(msg='Press ENTER to continue.')\newline
\newline
Print a message and wait until the user presses the ENTER key.\newline
\newline
INPUT:\newline
msg (optional): message\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

\paragraph{Method \texttt{warnmessage}}
\vspace{1ex}
\texttt{\newline
misc.warnmessage(caller,msg)\newline
\newline
Print a warning message\newline
\newline
INPUT:\newline
caller: caller label / name of the calling object (string)\newline
msg: warning message\newline
\newline
OUTPUT:\newline
(none)\newline
\newline
}

